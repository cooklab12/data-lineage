import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import org.springframework.jdbc.core.BatchPreparedStatementSetter;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.*;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.stream.Collectors;

@Service
public class TaskVariableService {
    
    private final TaskService taskService;
    private final ObjectMapper objectMapper;
    private final ExecutorService executorService;
    private final JdbcTemplate jdbcTemplate;
    private static final int BATCH_SIZE = 1000;
    
    public TaskVariableService(TaskService taskService, JdbcTemplate jdbcTemplate) {
        this.taskService = taskService;
        this.jdbcTemplate = jdbcTemplate;
        this.objectMapper = new ObjectMapper();
        this.executorService = Executors.newFixedThreadPool(
            Runtime.getRuntime().availableProcessors()
        );
    }
    
    /**
     * Data class to hold key-value pairs for batch processing
     */
    private static class KeyValuePair {
        String key;
        String jsonValue;
        
        KeyValuePair(String key, String jsonValue) {
            this.key = key;
            this.jsonValue = jsonValue;
        }
    }
    
    /**
     * Process tasks and insert their variables into database
     * @param taskName The name of the tasks to fetch
     * @return Number of records inserted
     */
    @Transactional
    public int processTaskVariablesAndSaveToDb(String taskName) {
        try {
            // Fetch and process tasks in parallel
            List<KeyValuePair> keyValuePairs = processTasksParallel(taskName);
            
            // Batch insert into database
            return batchInsertToDatabase(keyValuePairs);
            
        } catch (Exception e) {
            throw new RuntimeException("Error processing and saving task variables: " + e.getMessage(), e);
        }
    }
    
    /**
     * Process tasks in parallel to extract twrkey and its corresponding JSON
     */
    private List<KeyValuePair> processTasksParallel(String taskName) throws Exception {
        List<Task> activeTasks = taskService.createTaskQuery()
            .taskName(taskName)
            .active()
            .list();
        
        List<CompletableFuture<KeyValuePair>> futures = activeTasks.stream()
            .map(task -> CompletableFuture.supplyAsync(
                () -> processTaskVariables(task),
                executorService
            ))
            .collect(Collectors.toList());
        
        return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))
            .thenApply(v -> futures.stream()
                .map(CompletableFuture::join)
                .filter(Objects::nonNull) // Filter out tasks that don't have twrkey
                .collect(Collectors.toList())
            )
            .get();
    }
    
    /**
     * Process individual task variables
     */
    private KeyValuePair processTaskVariables(Task task) {
        try {
            Map<String, Object> variables = taskService.getVariables(task.getId());
            
            // Check if twrkey exists
            if (!variables.containsKey("twrkey")) {
                return null;
            }
            
            String twrkey = variables.get("twrkey").toString();
            
            // Create JSON object for all variables
            ObjectNode variablesJson = objectMapper.createObjectNode();
            
            // Add task metadata
            variablesJson.put("taskId", task.getId());
            variablesJson.put("taskName", task.getName());
            variablesJson.put("processInstanceId", task.getProcessInstanceId());
            
            // Add variables
            ObjectNode varsNode = variablesJson.putObject("variables");
            for (Map.Entry<String, Object> entry : variables.entrySet()) {
                addVariableToJson(varsNode, entry.getKey(), entry.getValue());
            }
            
            return new KeyValuePair(twrkey, variablesJson.toString());
            
        } catch (Exception e) {
            throw new RuntimeException("Error processing task " + task.getId(), e);
        }
    }
    
    /**
     * Add variable to JSON with type handling
     */
    private void addVariableToJson(ObjectNode node, String key, Object value) {
        if (value instanceof String) {
            node.put(key, (String) value);
        } else if (value instanceof Number) {
            node.put(key, (Number) value);
        } else if (value instanceof Boolean) {
            node.put(key, (Boolean) value);
        } else {
            node.put(key, value.toString());
        }
    }
    
    /**
     * Batch insert data into Oracle database
     */
    private int batchInsertToDatabase(List<KeyValuePair> keyValuePairs) {
        String sql = "INSERT INTO TASK_VARIABLES (KEY, VALUE) VALUES (?, ?)";
        int totalRecords = 0;
        
        for (int i = 0; i < keyValuePairs.size(); i += BATCH_SIZE) {
            final List<KeyValuePair> batch = keyValuePairs.subList(
                i, 
                Math.min(i + BATCH_SIZE, keyValuePairs.size())
            );
            
            jdbcTemplate.batchUpdate(sql, new BatchPreparedStatementSetter() {
                @Override
                public void setValues(PreparedStatement ps, int i) throws SQLException {
                    KeyValuePair pair = batch.get(i);
                    ps.setString(1, pair.key);
                    ps.setString(2, pair.jsonValue);
                }
                
                @Override
                public int getBatchSize() {
                    return batch.size();
                }
            });
            
            totalRecords += batch.size();
        }
        
        return totalRecords;
    }
    
    /**
     * Cleanup method
     */
    public void shutdown() {
        executorService.shutdown();
    }
}